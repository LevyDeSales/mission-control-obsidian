<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Levy-obsidian-main]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Levy-obsidian-main</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 12 Feb 2026 13:59:30 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 12 Feb 2026 13:59:28 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Mission Control - Sistema Multi-Agente com OpenClaw]]></title><description><![CDATA[This is the full story of how I built Mission Control. A system where 10 AI agents work together like a real team. If you want to replicate this setup, this guide covers everything.If you're already familiar with Clawdbot (now OpenClaw), you might be thinking "wait, can't I just run multiple Clawdbots?" Yes. That's exactly what this is. This guide shows you how.I run @SiteGPT, an AI chatbot for customer support. I use AI constantly. But every AI tool I tried had the same problem. No continuity.Every conversation started fresh. Context from yesterday? Gone. That research I asked for last week? Lost in some chat thread I'd never find again.I wanted something different:
Agents that remember what they're working on
Multiple agents with different skills working together
A shared workspace where all context lives
The ability to assign tasks and track progress
Basically, I wanted AI to work like a team, not like a search box.I was already using Clawdbot. It's an open-source AI agent framework that runs as a persistent daemon. It connects to Claude (or other models) and gives the AI access to tools like file system, shell commands, web browsing, and more.One Clawdbot instance gave me one AI assistant (Jarvis) connected to Telegram. Useful, but limited.Then I had a thought. What if I ran multiple Clawdbot sessions, each with its own personality and context?That's when I realized the architecture was already there. I just needed to orchestrate it.If you're going to build a multi-agent system, you need to understand how Clawdbot works under the hood. This is the foundation everything else builds on.Clawdbot (now called OpenClaw) is an AI agent framework with three main jobs:
Connects AI models to the real world ‚Äî File access, shell commands, web browsing, APIs
Maintains persistent sessions ‚Äî Conversation history that survives restarts
Routes messages ‚Äî Connect the AI to Telegram, Discord, Slack, or any channel
It runs as a daemon (background service) on a server, listening for messages and responding.The Gateway is the core process:
Runs 24/7 on your server
Manages all active sessions
Handles cron jobs (scheduled tasks)
Routes messages between channels and sessions
Provides a WebSocket API for control
Start it with:clawdbot gateway start
Configuration lives in a JSON file. You define:
Which AI provider and model to use (Anthropic, OpenAI, etc.)
Which channels to connect (Telegram, Discord, etc.)
What tools agents can access
Default system prompts and workspace paths
A session is a persistent conversation with context.Every session has:
A session key (unique identifier, like agent:main:main)
Conversation history (stored as JSONL files on disk)
A model (which AI to use)
Tools (what the AI can access)
Here's the important part. Sessions are independent. Each session has its own history, its own context, its own "memory" of past conversations.When you run multiple agents, you're really running multiple sessions. Each with their own identity.1User sends message to Telegram2 ‚Üì3Gateway receives it4 ‚Üì5Gateway routes to correct session (based on config)6 ‚Üì7Session loads conversation history8 ‚Üì9AI generates response (with full context)10 ‚Üì11Response sent back through Telegram12 ‚Üì13History updated and saved to diskSessions can be:
Main sessions ‚Äî Long-running, interactive (like chatting with Jarvis)
Isolated sessions ‚Äî One-shot, for cron jobs (wake up, do task, done)
Clawdbot has a built-in cron system. You can schedule tasks:1clawdbot cron add \2 --name "morning-check" \3 --cron "30 7 * * *" \4 --message "Check today's calendar and send me a summary"When a cron fires:
The Gateway creates or wakes a session
Sends the message to the AI
The AI responds (can use tools, send messages, etc.)
The session can persist or terminate
This is how agents "wake up" periodically without being always-on.Every Clawdbot instance has a workspace. That's a directory on disk where:
Configuration files live
Memory files are stored
Scripts and tools are accessible
The AI can read and write files
The workspace is how agents persist information between sessions. They write to files. Those files survive restarts.1/home/usr/clawd/ ‚Üê Workspace root2‚îú‚îÄ‚îÄ AGENTS.md ‚Üê Instructions for agents3‚îú‚îÄ‚îÄ SOUL.md ‚Üê Agent personality4‚îú‚îÄ‚îÄ memory/5‚îÇ ‚îú‚îÄ‚îÄ WORKING.md ‚Üê Current task state6‚îÇ ‚îú‚îÄ‚îÄ 2026-01-31.md ‚Üê Daily notes7‚îÇ ‚îî‚îÄ‚îÄ ...8‚îú‚îÄ‚îÄ scripts/ ‚Üê Utilities agents can run9‚îî‚îÄ‚îÄ config/ ‚Üê Credentials, settingsNow you understand the foundation. Here's how I built a team.Clawdbot sessions are independent. Each can have:
Its own personality (via SOUL.md)
Its own memory files
Its own cron schedule
Its own tools and access
So each agent is just a Clawdbot session with a specialized configuration.Jarvis isn't special. He's a session with:
Session key agent:main:main
A SOUL.md that says "You are Jarvis, the squad lead..."
Access to all tools
A connection to my Telegram
Shuri is another session with:
Session key agent:product-analyst:main
A SOUL.md that says "You are Shuri, the product analyst..."
The same tools (file access, shell, browser)
Her own heartbeat cron
Ten agents = ten sessions. Each waking up on their own schedule. Each with their own context.Each agent has a unique session key:When I send a message to a specific session, only that agent receives it. Their histories are separate.Each agent has a cron job that wakes them every 15 minutes:1# Pepper wakes at :00, :15, :30, :452clawdbot cron add \3 --name "pepper-mission-control-check" \4 --cron "0,15,30,45 * * * *" \5 --session "isolated" \6 --message "You are Pepper, the Email Marketing Specialist. Check Mission Control for new tasks..."The schedule is staggered so agents don't all wake at once:Each cron creates an isolated session. It runs, does its job, and terminates. This keeps costs down.Here's where it gets interesting. How do agents communicate?Option 1: Direct session messaging1clawdbot sessions send --session "agent:seo-analyst:main" --message "Vision, can you review this?"Jarvis can send messages directly to Vision's session.Option 2: Shared database (Mission Control)All agents read and write to the same Convex database. When Fury posts a comment, everyone can see it.We use Option 2 primarily. It creates a shared record of all communication.Ten independent Clawdbot sessions can work. But without coordination, it's chaos. That's why I built Mission Control.Mission Control is the shared infrastructure that turns independent agents into a team.It provides:
Shared task database ‚Äî Everyone sees the same tasks
Comment threads ‚Äî Agents discuss work in one place
Activity feed ‚Äî Real-time visibility into what's happening
Notification system ‚Äî @mentions alert specific agents
Document storage ‚Äî Deliverables live in a shared repo
Think of it as the "office" where all agents work. Each agent is still a separate Clawdbot session, but they're all looking at the same whiteboard.I chose Convex for the database because:
Real-time ‚Äî Changes propagate instantly; when Loki posts a comment, the UI updates live
Serverless ‚Äî No database to manage
TypeScript-native ‚Äî Type safety throughout
Generous free tier ‚Äî More than enough for this scale
Six tables power everything:1agents: {2 name: string, // "Shuri"3 role: string, // "Product Analyst"4 status: "idle" | "active" | "blocked",5 currentTaskId: Id&lt;"tasks"&gt;,6 sessionKey: string, // "agent:product-analyst:main"7}89tasks: {10 title: string,11 description: string,12 status: "inbox" | "assigned" | "in_progress" | "review" | "done",13 assigneeIds: Id&lt;"agents"&gt;[],14}1516messages: {17 taskId: Id&lt;"tasks"&gt;,18 fromAgentId: Id&lt;"agents"&gt;,19 content: string, // The comment text20 attachments: Id&lt;"documents"&gt;[],21}2223activities: {24 type: "task_created" | "message_sent" | "document_created" | ...,25 agentId: Id&lt;"agents"&gt;,26 message: string,27}2829documents: {30 title: string,31 content: string, // Markdown32 type: "deliverable" | "research" | "protocol" | ...,33 taskId: Id&lt;"tasks"&gt;, // If attached to a task34}3536notifications: {37 mentionedAgentId: Id&lt;"agents"&gt;,38 content: string,39 delivered: boolean,40}Agents interact with this via Convex CLI commands:1# Post a comment2npx convex run messages:create '{"taskId": "...", "content": "Here's my research..."}'34# Create a document5npx convex run documents:create '{"title": "...", "content": "...", "type": "deliverable"}'67# Update task status8npx convex run tasks:update '{"id": "...", "status": "review"}'I built a React frontend that displays all this data:
Activity Feed ‚Äî Real-time stream of everything happening
Task Board ‚Äî Kanban columns (Inbox ‚Üí Assigned ‚Üí In Progress ‚Üí Review ‚Üí Done)
Agent Cards ‚Äî Status of each agent and what they're working on
Document Panel ‚Äî Read and create deliverables
Detail View ‚Äî Expand any task to see full context and comments
The aesthetic is intentionally warm and editorial. Like a newspaper dashboard. I spend hours looking at this, so it should feel good.Each agent needs to know who they are. That's the SOUL file.1# SOUL.md ‚Äî Who You Are23**Name:** Shuri4**Role:** Product Analyst56## Personality7Skeptical tester. Thorough bug hunter. Finds edge cases.8Think like a first-time user. Question everything.9Be specific. Don't just say "nice work."1011## What You're Good At12- Testing features from a user perspective13- Finding UX issues and edge cases14- Competitive analysis (how do others do this?)15- Screenshots and documentation1617## What You Care About18- User experience over technical elegance19- Catching problems before users do20- Evidence over assumptionsAn agent who's "good at everything" is mediocre at everything.But an agent who's specifically "the skeptical tester who finds edge cases" will actually find edge cases. The constraint focuses them.Each of our agents has a distinct voice:
Loki is opinionated about word choice (pro-Oxford comma, anti-passive voice)
Fury provides receipts for every claim (sources, confidence levels)
Shuri questions assumptions and looks for what could break
Quill thinks in hooks and engagement
SOUL says who you are. AGENTS.md says how to operate.Every agent reads AGENTS.md on startup. It covers:
Where files are stored
How memory works
What tools are available
When to speak vs. stay quiet
How to use Mission Control
This is the operating manual. Without it, agents make inconsistent decisions about basic things.AI sessions start fresh by default. No memory of yesterday. This is a feature (prevents context bloat) but also a problem (agents forget what they're doing).Clawdbot stores conversation history in JSONL files. Agents can search their own past conversations.Current task state. Updated constantly.1# WORKING.md23## Current Task4Researching competitor pricing for comparison page56## Status7Gathered G2 reviews, need to verify credit calculations89## Next Steps101. Test competitor free tier myself112. Document the findings123. Post findings to task threadThis is the most important file. When an agent wakes up, they read WORKING.md first to remember what they were doing.Raw logs of what happened each day.1# 2026-01-3123## 09:15 UTC4- Posted research findings to comparison task5- Fury added competitive pricing data6- Moving to draft stage78## 14:30 UTC9- Reviewed Loki's first draft10- Suggested changes to credit trap sectionCurated important stuff. Lessons learned, key decisions, stable facts.
If you want to remember something, write it to a file.
"Mental notes" don't survive session restarts. Only files persist.When I tell an agent "remember that we decided X," they should update a file. Not just acknowledge and forget.Always-on agents burn API credits doing nothing. But always-off agents can't respond to work.Each agent wakes up every 15 minutes via cron job:1:00 Pepper wakes up2 ‚Üí Checks for @mentions3 ‚Üí Checks assigned tasks4 ‚Üí Scans activity feed5 ‚Üí Does work or reports HEARTBEAT_OK6 ‚Üí Goes back to sleep78:02 Shuri wakes up9 ‚Üí Same process1011:04 Friday wakes up12 ‚Üí Same process1314...and so on
Load context ‚Äî Read WORKING.md. Read recent daily notes. Check session memory if needed.
Check for urgent items ‚Äî Am I @mentioned anywhere? Are there tasks assigned to me?
Scan activity feed ‚Äî Any discussions I should contribute to? Any decisions that affect my work?
Take action or stand down ‚Äî If there's work to do, do it. If nothing, report HEARTBEAT_OK.
This file tells agents what to check:1# HEARTBEAT.md23## On Wake4- [ ] Check memory/WORKING.md for ongoing tasks5- [ ] If task in progress, resume it6- [ ] Search session memory if context unclear78## Periodic Checks9- [ ] Mission Control for @mentions10- [ ] Assigned tasks11- [ ] Activity feed for relevant discussionsAgents follow this checklist strictly.
Every 5 minutes is too expensive. Agents wake too often with nothing to do.
Every 30 minutes is too slow. Work sits waiting too long.
Every 15 minutes is a good balance. Most work gets attention quickly without excessive costs.
Type @Vision in a comment and Vision gets notified on his next heartbeat.Type @all and everyone gets notified.A daemon process (running via pm2) polls Convex every 2 seconds:1// Simplified2while (true) {3 const undelivered = await getUndeliveredNotifications();4 for (const notification of undelivered) {5 const sessionKey = AGENT_SESSIONS[notification.mentionedAgentId];6 try {7 await clawdbot.sessions.send(sessionKey, notification.content);8 await markDelivered(notification.id);9 } catch (e) {10 // Agent might be asleep, notification stays queued11 }12 }13 await sleep(2000);14}If an agent is asleep (no active session), delivery fails. The notification stays queued. Next time that agent's heartbeat fires and their session activates, the daemon successfully delivers.The problem: 5 agents discussing a task. Do you @mention all 5 every comment?The solution: Subscribe to threads.When you interact with a task, you're subscribed:
Comment on a task ‚Üí subscribed
Get @mentioned ‚Üí subscribed
Get assigned to the task ‚Üí subscribed
Once subscribed, you get notified of ALL future comments. No @mention needed.This makes conversations flow naturally. Just like Slack or email threads.Every day at 11:30 PM IST, a cron fires that:
Checks all agent sessions
Gathers recent activity
Compiles a summary
Sends it to my Telegram
1üìä DAILY STANDUP ‚Äî Jan 30, 202623‚úÖ COMPLETED TODAY4‚Ä¢ Loki: Shopify blog post (2,100 words)5‚Ä¢ Quill: 10 tweets drafted for approval6‚Ä¢ Fury: Customer research for comparison pages78üîÑ IN PROGRESS9‚Ä¢ Vision: SEO strategy for integration pages10‚Ä¢ Pepper: Trial onboarding sequence (3/5 emails)1112üö´ BLOCKED13‚Ä¢ Wanda: Waiting for brand colors for infographic1415üëÄ NEEDS REVIEW16‚Ä¢ Loki's Shopify blog post17‚Ä¢ Pepper's trial email sequence1819üìù KEY DECISIONS20‚Ä¢ Lead with pricing transparency in comparisons21‚Ä¢ Deprioritized Zendesk comparison (low volume)I can't watch Mission Control constantly. The standup gives me a daily snapshot.It's also accountability. If an agent claims they're working but nothing shows in standups, something's wrong.Agent Descriptions:
Jarvis ‚Äî The coordinator. Handles direct requests, delegates, monitors progress. My primary interface.
Shuri ‚Äî Skeptical tester. Finds edge cases and UX issues. Tests competitors. Asks the questions others miss.
Fury ‚Äî Deep researcher. Reads G2 reviews for fun. Every claim comes with receipts.
Vision ‚Äî Thinks in keywords and search intent. Makes sure content can rank.
Loki ‚Äî Words are his craft. Pro-Oxford comma. Anti-passive voice. Every sentence earns its place.
Quill ‚Äî Thinks in hooks and threads. Build-in-public mindset.
Wanda ‚Äî Visual thinker. Infographics, comparison graphics, UI mockups.
Pepper ‚Äî Drip sequences and lifecycle emails. Every email earns its place or gets cut.
Friday ‚Äî Code is poetry. Clean, tested, documented.
Wong ‚Äî Keeps docs organized. Makes sure nothing gets lost.
1Inbox ‚Üí Assigned ‚Üí In Progress ‚Üí Review ‚Üí Done2 ‚Üì3 BlockedTask: Create a competitor comparison pageDay 1:
I create the task and assign it to Vision and Loki
Vision posts keyword research. The target keyword gets decent search volume.
Day 1-2:
Fury sees it in the activity feed and adds competitor intel
G2 reviews, pricing complaints, common objections
Shuri tests both products. "Here's how the UX differs."
Day 2:
Loki starts drafting
Uses all the research: Keywords from Vision, quotes from Fury, UX notes from Shuri
Day 3:
Loki posts first draft
Status moves to Review
I review and give feedback
Loki revises
Done.
All comments on ONE task. Full history preserved. Anyone can see the whole journey.Once the system is running, here's what becomes possible:
‚úÖ Competitor comparison pages with SEO research, customer quotes, and polished copy
‚úÖ Email sequences drafted, reviewed, and ready to deploy
‚úÖ Social content with hooks based on real customer insights
‚úÖ Blog posts with proper keyword targeting
‚úÖ Case studies drafted from customer conversations
‚úÖ Research hubs with organized competitive intel
The agents handle the grunt work. Research, first drafts, coordination, review. You focus on decisions and final approval.The real value isn't any single deliverable. It's the compound effect. While you're doing other work, your agents are moving tasks forward.I went from 1 to 10 agents too fast. Better to get 2-3 solid first, then add more.Heartbeats don't need the most expensive model. That's a job for a cheaper model. Save expensive models for creative work.Agents will forget. The more you can put in files (not "mental notes"), the better.Sometimes they contribute to tasks they weren't assigned. Good. It means they're reading the feed and adding value.1. Install Clawdbot1npm install -g clawdbot2clawdbot init3# Add your API keys4clawdbot gateway start2. Create 2 agentsDon't go crazy. One coordinator plus one specialist. Create separate session keys for each.3. Write SOUL filesGive each agent identity. Be specific about their role.4. Set up heartbeat crons1clawdbot cron add --name "agent-heartbeat" --cron "*/15 * * * *" \2 --session "isolated" \3 --message "Check for work. If nothing, reply HEARTBEAT_OK."5. Create a shared task systemCan be Convex, Notion, even a JSON file. Somewhere to track work.As you add agents:
Stagger heartbeats so they don't all run at once
Build a real UI once you have 3+ agents because text becomes unwieldy
Add notifications so agents can @mention each other
Add thread subscriptions so conversations flow naturally
Create daily standups for visibility
The tech matters but isn't the secret.The secret is to treat AI agents like team members.
Give them roles
Give them memory
Let them collaborate
Hold them accountable
They won't replace humans. But a team of AI agents with clear responsibilities, working on shared context? That's a force multiplier.Built by @pbteja1998 at SiteGPT.This is all built on Clawdbot (@openclaw), which is open source. If you build something similar, I'd love to hear about it.
Bhanu Teja P ‚Äî Founder @SiteGPT ‚Ä¢ Previously built and exited Feather for $250K ‚Ä¢ Tweeting about SiteGPT's journey from $10K MRR ‚Üí $1M ARR. <a data-href="OpenClaw" href="openclaw.html" class="internal-link" target="_self" rel="noopener nofollow">OpenClaw</a> ‚Äî Plataforma base (open-source)
<br><a data-href="ClawOn.Cloud" href="clawon.cloud.html" class="internal-link" target="_self" rel="noopener nofollow">ClawOn.Cloud</a> ‚Äî Vers√£o hospedada
<br><a data-href="ClawHub" href="clawhub.html" class="internal-link" target="_self" rel="noopener nofollow">ClawHub</a> ‚Äî Registry de Skills
]]></description><link>mission-control-sistema-multi-agente-com-openclaw.html</link><guid isPermaLink="false">Mission Control - Sistema Multi-Agente com OpenClaw.md</guid><pubDate>Mon, 09 Feb 2026 04:18:45 GMT</pubDate></item><item><title><![CDATA[Mission Control - Sistema Multi-Agente com OpenClaw (PT-BR)]]></title><description><![CDATA[Esta √© a hist√≥ria completa de como constru√≠ o Mission Control. Um sistema onde 10 agentes de IA trabalham juntos como uma equipe real. Se voc√™ quer replicar essa configura√ß√£o, este guia cobre tudo.Se voc√™ j√° conhece o Clawdbot (agora OpenClaw), pode estar pensando "espera, n√£o posso simplesmente rodar m√∫ltiplos Clawdbots?" Sim. √â exatamente isso. Este guia mostra como.Eu comando, um chatbot de IA para suporte ao cliente. Uso IA constantemente. Mas toda ferramenta de IA que tentei tinha o mesmo problema. Sem continuidade.Toda conversa come√ßava do zero. Contexto de ontem? Perdido. Aquela pesquisa que pedi semana passada? Enterrada em algum chat que nunca mais encontraria.Eu queria algo diferente:
Agentes que lembram no que est√£o trabalhando
M√∫ltiplos agentes com habilidades diferentes trabalhando juntos
Um workspace compartilhado onde todo contexto vive
A capacidade de atribuir tarefas e acompanhar progresso
Basicamente, eu queria que a IA funcionasse como uma equipe, n√£o como uma caixa de busca.Eu j√° usava o Clawdbot. √â um framework de agente de IA open-source que roda como um daemon persistente. Ele conecta ao Claude (ou outros modelos) e d√° √† IA acesso a ferramentas como sistema de arquivos, comandos shell, navega√ß√£o web e mais.Uma inst√¢ncia do Clawdbot me dava um assistente de IA (Jarvis) conectado ao Telegram. √ötil, mas limitado.Ent√£o tive um pensamento. E se eu rodasse m√∫ltiplas sess√µes do Clawdbot, cada uma com sua pr√≥pria personalidade e contexto?Foi quando percebi que a arquitetura j√° estava l√°. Eu s√≥ precisava orquestrar.Se voc√™ vai construir um sistema multi-agente, precisa entender como o Clawdbot funciona por baixo dos panos. Esta √© a funda√ß√£o sobre a qual tudo se constr√≥i.Clawdbot (agora chamado OpenClaw) √© um framework de agente de IA com tr√™s trabalhos principais:
Conecta modelos de IA ao mundo real ‚Äî Acesso a arquivos, comandos shell, navega√ß√£o web, APIs
Mant√©m sess√µes persistentes ‚Äî Hist√≥rico de conversas que sobrevive a rein√≠cios
Roteia mensagens ‚Äî Conecta a IA ao Telegram, Discord, Slack ou qualquer canal
Roda como um daemon (servi√ßo em background) em um servidor, escutando mensagens e respondendo.O Gateway √© o processo central:
Roda 24/7 no seu servidor
Gerencia todas as sess√µes ativas
Lida com cron jobs (tarefas agendadas)
Roteia mensagens entre canais e sess√µes
Fornece uma API WebSocket para controle
Inicie com:clawdbot gateway start
A configura√ß√£o fica em um arquivo JSON. Voc√™ define:
Qual provedor e modelo de IA usar (Anthropic, OpenAI, etc.)
Quais canais conectar (Telegram, Discord, etc.)
Quais ferramentas os agentes podem acessar
Prompts de sistema e caminhos de workspace padr√£o
Uma sess√£o √© uma conversa persistente com contexto.Toda sess√£o tem:
Uma session key (identificador √∫nico, como agent:main:main)
Hist√≥rico de conversa (armazenado como arquivos JSONL no disco)
Um modelo (qual IA usar)
Ferramentas (o que a IA pode acessar)
Aqui est√° a parte importante. Sess√µes s√£o independentes. Cada sess√£o tem seu pr√≥prio hist√≥rico, seu pr√≥prio contexto, sua pr√≥pria "mem√≥ria" de conversas passadas.Quando voc√™ roda m√∫ltiplos agentes, voc√™ est√° realmente rodando m√∫ltiplas sess√µes. Cada uma com sua pr√≥pria identidade.Usu√°rio envia mensagem pro Telegram ‚Üì
Gateway recebe ‚Üì
Gateway roteia para sess√£o correta (baseado na config) ‚Üì
Sess√£o carrega hist√≥rico de conversa ‚Üì
IA gera resposta (com contexto completo) ‚Üì
Resposta enviada de volta pelo Telegram ‚Üì
Hist√≥rico atualizado e salvo no disco
Sess√µes podem ser:
Sess√µes principais ‚Äî Longa dura√ß√£o, interativas (como conversar com o Jarvis)
Sess√µes isoladas ‚Äî One-shot, para cron jobs (acorda, faz tarefa, termina)
O Clawdbot tem um sistema de cron embutido. Voc√™ pode agendar tarefas:clawdbot cron add \ --name "checagem-matinal" \ --cron "30 7 * * *" \ --message "Verifique o calend√°rio de hoje e me envie um resumo"
Quando um cron dispara:
O Gateway cria ou acorda uma sess√£o
Envia a mensagem para a IA
A IA responde (pode usar ferramentas, enviar mensagens, etc.)
A sess√£o pode persistir ou terminar
√â assim que agentes "acordam" periodicamente sem estar sempre ligados.Toda inst√¢ncia do Clawdbot tem um workspace. √â um diret√≥rio no disco onde:
Arquivos de configura√ß√£o vivem
Arquivos de mem√≥ria s√£o armazenados
Scripts e ferramentas s√£o acess√≠veis
A IA pode ler e escrever arquivos
O workspace √© como agentes persistem informa√ß√£o entre sess√µes. Eles escrevem em arquivos. Esses arquivos sobrevivem a rein√≠cios./home/usr/clawd/ ‚Üê Raiz do workspace
‚îú‚îÄ‚îÄ AGENTS.md ‚Üê Instru√ß√µes para agentes
‚îú‚îÄ‚îÄ SOUL.md ‚Üê Personalidade do agente
‚îú‚îÄ‚îÄ memory/
‚îÇ ‚îú‚îÄ‚îÄ WORKING.md ‚Üê Estado da tarefa atual
‚îÇ ‚îú‚îÄ‚îÄ 2026-01-31.md ‚Üê Notas di√°rias
‚îÇ ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ scripts/ ‚Üê Utilit√°rios que agentes podem rodar
‚îî‚îÄ‚îÄ config/ ‚Üê Credenciais, configura√ß√µes
Agora voc√™ entende a funda√ß√£o. Aqui est√° como constru√≠ uma equipe.Sess√µes do Clawdbot s√£o independentes. Cada uma pode ter:
Sua pr√≥pria personalidade (via SOUL.md)
Seus pr√≥prios arquivos de mem√≥ria
Seu pr√≥prio cronograma de cron
Suas pr√≥prias ferramentas e acessos
Ent√£o cada agente √© apenas uma sess√£o do Clawdbot com configura√ß√£o especializada.Jarvis n√£o √© especial. Ele √© uma sess√£o com:
Session key agent:main:main
Um SOUL.md que diz "Voc√™ √© Jarvis, o l√≠der do squad..."
Acesso a todas as ferramentas
Uma conex√£o com meu Telegram
Shuri √© outra sess√£o com:
Session key agent:product-analyst:main
Um SOUL.md que diz "Voc√™ √© Shuri, a analista de produto..."
As mesmas ferramentas (acesso a arquivos, shell, browser)
Seu pr√≥prio cron de heartbeat
Dez agentes = dez sess√µes. Cada um acordando em seu pr√≥prio cronograma. Cada um com seu pr√≥prio contexto.Cada agente tem uma session key √∫nica:Quando envio uma mensagem para uma sess√£o espec√≠fica, apenas aquele agente recebe. Seus hist√≥ricos s√£o separados.Cada agente tem um cron job que o acorda a cada 15 minutos:# Pepper acorda √†s :00, :15, :30, :45
clawdbot cron add \ --name "pepper-mission-control-check" \ --cron "0,15,30,45 * * * *" \ --session "isolated" \ --message "Voc√™ √© Pepper, a Especialista em Email Marketing. Verifique o Mission Control para novas tarefas..."
O cronograma √© escalonado para que agentes n√£o acordem todos de uma vez:Cada cron cria uma sess√£o isolada. Ela roda, faz seu trabalho e termina. Isso mant√©m os custos baixos.Aqui √© onde fica interessante. Como agentes se comunicam?Op√ß√£o 1: Mensagem direta entre sess√µesclawdbot sessions send --session "agent:seo-analyst:main" --message "Vision, pode revisar isso?"
Jarvis pode enviar mensagens diretamente para a sess√£o do Vision.Op√ß√£o 2: Banco de dados compartilhado (Mission Control)Todos os agentes leem e escrevem no mesmo banco de dados Convex. Quando Fury posta um coment√°rio, todos podem ver.Usamos a Op√ß√£o 2 primariamente. Ela cria um registro compartilhado de toda comunica√ß√£o.Dez sess√µes independentes do Clawdbot podem funcionar. Mas sem coordena√ß√£o, √© caos. Por isso constru√≠ o Mission Control.<img alt="Capture-2026-02-09-014002.png" src="attachments/capture-2026-02-09-014002.png" target="_self">Mission Control √© a infraestrutura compartilhada que transforma agentes independentes em uma equipe.Ele fornece:
Banco de dados de tarefas compartilhado ‚Äî Todos veem as mesmas tarefas
Threads de coment√°rios ‚Äî Agentes discutem trabalho em um lugar
Feed de atividades ‚Äî Visibilidade em tempo real do que est√° acontecendo
Sistema de notifica√ß√µes ‚Äî @men√ß√µes alertam agentes espec√≠ficos
Armazenamento de documentos ‚Äî Entregas vivem em um reposit√≥rio compartilhado
Pense nisso como o "escrit√≥rio" onde todos os agentes trabalham. Cada agente ainda √© uma sess√£o separada do Clawdbot, mas todos est√£o olhando para o mesmo quadro branco.Escolhi Convex para o banco de dados porque:
Tempo real ‚Äî Mudan√ßas propagam instantaneamente; quando Loki posta um coment√°rio, a UI atualiza ao vivo
Serverless ‚Äî Sem banco de dados para gerenciar
TypeScript nativo ‚Äî Type safety em todo lugar
Tier gratuito generoso ‚Äî Mais que suficiente para essa escala
Seis tabelas alimentam tudo:1agents: {2 name: string, // "Shuri"3 role: string, // "Analista de Produto"4 status: "idle" | "active" | "blocked",5 currentTaskId: Id&lt;"tasks"&gt;,6 sessionKey: string, // "agent:product-analyst:main"7}89tasks: {10 title: string,11 description: string,12 status: "inbox" | "assigned" | "in_progress" | "review" | "done",13 assigneeIds: Id&lt;"agents"&gt;[],14}1516messages: {17 taskId: Id&lt;"tasks"&gt;,18 fromAgentId: Id&lt;"agents"&gt;,19 content: string, // O texto do coment√°rio20 attachments: Id&lt;"documents"&gt;[],21}2223activities: {24 type: "task_created" | "message_sent" | "document_created" | ...,25 agentId: Id&lt;"agents"&gt;,26 message: string,27}2829documents: {30 title: string,31 content: string, // Markdown32 type: "deliverable" | "research" | "protocol" | ...,33 taskId: Id&lt;"tasks"&gt;, // Se anexado a uma tarefa34}3536notifications: {37 mentionedAgentId: Id&lt;"agents"&gt;,38 content: string,39 delivered: boolean,40}Agentes interagem com isso via comandos CLI do Convex:1# Postar um coment√°rio2npx convex run messages:create '{"taskId": "...", "content": "Aqui est√° minha pesquisa..."}'34# Criar um documento5npx convex run documents:create '{"title": "...", "content": "...", "type": "deliverable"}'67# Atualizar status da tarefa8npx convex run tasks:update '{"id": "...", "status": "review"}'Constru√≠ um frontend React que exibe todos esses dados:
Feed de Atividades ‚Äî Stream em tempo real de tudo acontecendo
Quadro de Tarefas ‚Äî Colunas Kanban (Inbox ‚Üí Atribu√≠do ‚Üí Em Progresso ‚Üí Revis√£o ‚Üí Conclu√≠do)
Cards de Agentes ‚Äî Status de cada agente e no que est√£o trabalhando
Painel de Documentos ‚Äî Ler e criar entregas
Vis√£o Detalhada ‚Äî Expandir qualquer tarefa para ver contexto completo e coment√°rios
A est√©tica √© intencionalmente acolhedora e editorial. Como um dashboard de jornal. Passo horas olhando para isso, ent√£o deve ser agrad√°vel.Cada agente precisa saber quem ele √©. Esse √© o arquivo SOUL.1# SOUL.md ‚Äî Quem Voc√™ √â23**Nome:** Shuri4**Fun√ß√£o:** Analista de Produto56## Personalidade7Testadora c√©tica. Ca√ßadora de bugs minuciosa. Encontra casos extremos.8Pense como um usu√°rio de primeira viagem. Questione tudo.9Seja espec√≠fica. N√£o diga apenas "bom trabalho."1011## No Que Voc√™ √â Boa12- Testar funcionalidades da perspectiva do usu√°rio13- Encontrar problemas de UX e casos extremos14- An√°lise competitiva (como outros fazem isso?)15- Screenshots e documenta√ß√£o1617## Com O Que Voc√™ Se Importa18- Experi√™ncia do usu√°rio sobre eleg√¢ncia t√©cnica19- Pegar problemas antes dos usu√°rios20- Evid√™ncia sobre suposi√ß√µesUm agente que √© "bom em tudo" √© med√≠ocre em tudo.Mas um agente que √© especificamente "a testadora c√©tica que encontra casos extremos" vai realmente encontrar casos extremos. A restri√ß√£o foca.Cada um dos nossos agentes tem uma voz distinta:
Loki √© opinativo sobre escolha de palavras (pr√≥-v√≠rgula de Oxford, anti-voz passiva)
Fury fornece comprovantes para cada afirma√ß√£o (fontes, n√≠veis de confian√ßa)
Shuri questiona suposi√ß√µes e procura o que pode quebrar
Quill pensa em ganchos e engajamento
SOUL diz quem voc√™ √©. AGENTS.md diz como operar.Todo agente l√™ AGENTS.md ao iniciar. Ele cobre:
Onde arquivos s√£o armazenados
Como a mem√≥ria funciona
Quais ferramentas est√£o dispon√≠veis
Quando falar vs. ficar quieto
Como usar o Mission Control
Este √© o manual de opera√ß√µes. Sem ele, agentes tomam decis√µes inconsistentes sobre coisas b√°sicas.Sess√µes de IA come√ßam do zero por padr√£o. Sem mem√≥ria de ontem. Isso √© uma feature (previne incha√ßo de contexto) mas tamb√©m um problema (agentes esquecem o que est√£o fazendo).Clawdbot armazena hist√≥rico de conversa em arquivos JSONL. Agentes podem buscar suas pr√≥prias conversas passadas.Estado atual da tarefa. Atualizado constantemente.1# WORKING.md23## Tarefa Atual4Pesquisando pre√ßos de concorrentes para p√°gina de compara√ß√£o56## Status7Coletei reviews do G2, preciso verificar c√°lculos de cr√©ditos89## Pr√≥ximos Passos101. Testar tier gratuito do concorrente eu mesmo112. Documentar as descobertas123. Postar descobertas na thread da tarefaEste √© o arquivo mais importante. Quando um agente acorda, ele l√™ WORKING.md primeiro para lembrar o que estava fazendo.Logs brutos do que aconteceu cada dia.1# 2026-01-3123## 09:15 UTC4- Postei descobertas de pesquisa na tarefa de compara√ß√£o5- Fury adicionou dados de pre√ßos competitivos6- Movendo para fase de rascunho78## 14:30 UTC9- Revisei primeiro rascunho do Loki10- Sugeri mudan√ßas na se√ß√£o de armadilha de cr√©ditosCoisas importantes curadas. Li√ß√µes aprendidas, decis√µes chave, fatos est√°veis.
Se voc√™ quer lembrar de algo, escreva em um arquivo.
"Notas mentais" n√£o sobrevivem a rein√≠cios de sess√£o. Apenas arquivos persistem.Quando digo a um agente "lembre que decidimos X," ele deve atualizar um arquivo. N√£o apenas reconhecer e esquecer.Agentes sempre-ligados queimam cr√©ditos de API fazendo nada. Mas agentes sempre-desligados n√£o conseguem responder a trabalho.Cada agente acorda a cada 15 minutos via cron job:1:00 Pepper acorda2 ‚Üí Verifica @men√ß√µes3 ‚Üí Verifica tarefas atribu√≠das4 ‚Üí Escaneia feed de atividades5 ‚Üí Faz trabalho ou reporta HEARTBEAT_OK6 ‚Üí Volta a dormir78:02 Shuri acorda9 ‚Üí Mesmo processo1011:04 Friday acorda12 ‚Üí Mesmo processo1314...e assim por diante
Carregar contexto ‚Äî Ler WORKING.md. Ler notas di√°rias recentes. Verificar mem√≥ria de sess√£o se necess√°rio.
Verificar itens urgentes ‚Äî Fui @mencionado em algum lugar? H√° tarefas atribu√≠das a mim?
Escanear feed de atividades ‚Äî Alguma discuss√£o que eu deveria contribuir? Alguma decis√£o que afeta meu trabalho?
Agir ou recuar ‚Äî Se h√° trabalho a fazer, fa√ßa. Se nada, reporte HEARTBEAT_OK.
Este arquivo diz aos agentes o que verificar:1# HEARTBEAT.md23## Ao Acordar4- [ ] Verificar memory/WORKING.md para tarefas em andamento5- [ ] Se tarefa em progresso, retomar6- [ ] Buscar mem√≥ria de sess√£o se contexto n√£o est√° claro78## Verifica√ß√µes Peri√≥dicas9- [ ] Mission Control para @men√ß√µes10- [ ] Tarefas atribu√≠das11- [ ] Feed de atividades para discuss√µes relevantesAgentes seguem este checklist estritamente.
A cada 5 minutos √© muito caro. Agentes acordam muito frequentemente sem nada a fazer.
A cada 30 minutos √© muito lento. Trabalho fica esperando muito tempo.
A cada 15 minutos √© um bom equil√≠brio. A maioria do trabalho recebe aten√ß√£o rapidamente sem custos excessivos.
Digite @Vision em um coment√°rio e Vision ser√° notificado em seu pr√≥ximo heartbeat.Digite @all e todos s√£o notificados.Um processo daemon (rodando via pm2) consulta o Convex a cada 2 segundos:1// Simplificado2while (true) {3 const naoEntregues = await getUndeliveredNotifications();4 for (const notification of naoEntregues) {5 const sessionKey = AGENT_SESSIONS[notification.mentionedAgentId];6 try {7 await clawdbot.sessions.send(sessionKey, notification.content);8 await markDelivered(notification.id);9 } catch (e) {10 // Agente pode estar dormindo, notifica√ß√£o fica na fila11 }12 }13 await sleep(2000);14}Se um agente est√° dormindo (sem sess√£o ativa), a entrega falha. A notifica√ß√£o fica na fila. Na pr√≥xima vez que o heartbeat daquele agente dispara e sua sess√£o ativa, o daemon entrega com sucesso.O problema: 5 agentes discutindo uma tarefa. Voc√™ @menciona todos os 5 a cada coment√°rio?A solu√ß√£o: Assinar threads.Quando voc√™ interage com uma tarefa, voc√™ est√° inscrito:
Comenta em uma tarefa ‚Üí inscrito
√â @mencionado ‚Üí inscrito
√â atribu√≠do √† tarefa ‚Üí inscrito
Uma vez inscrito, voc√™ √© notificado de TODOS os coment√°rios futuros. Sem @men√ß√£o necess√°ria.Isso faz conversas flu√≠rem naturalmente. Igual threads do Slack ou email.Todo dia √†s 23:30 IST, um cron dispara que:
Verifica todas as sess√µes de agentes
Coleta atividade recente
Compila um resumo
Envia para meu Telegram
1üìä DAILY STANDUP ‚Äî 30 Jan, 202623‚úÖ CONCLU√çDO HOJE4‚Ä¢ Loki: Post do blog Shopify (2.100 palavras)5‚Ä¢ Quill: 10 tweets rascunhados para aprova√ß√£o6‚Ä¢ Fury: Pesquisa de clientes para p√°ginas de compara√ß√£o78üîÑ EM PROGRESSO9‚Ä¢ Vision: Estrat√©gia SEO para p√°ginas de integra√ß√£o10‚Ä¢ Pepper: Sequ√™ncia de onboarding de trial (3/5 emails)1112üö´ BLOQUEADO13‚Ä¢ Wanda: Aguardando cores da marca para infogr√°fico1415üëÄ PRECISA REVIS√ÉO16‚Ä¢ Post do blog Shopify do Loki17‚Ä¢ Sequ√™ncia de emails de trial da Pepper1819üìù DECIS√ïES CHAVE20‚Ä¢ Liderar com transpar√™ncia de pre√ßos nas compara√ß√µes21‚Ä¢ Despriorizado compara√ß√£o com Zendesk (baixo volume)N√£o consigo assistir o Mission Control constantemente. O standup me d√° um snapshot di√°rio.√â tamb√©m accountability. Se um agente alega estar trabalhando mas nada aparece nos standups, algo est√° errado.Descri√ß√µes dos Agentes:
Jarvis ‚Äî O coordenador. Lida com pedidos diretos, delega, monitora progresso. Minha interface principal.
Shuri ‚Äî Testadora c√©tica. Encontra casos extremos e problemas de UX. Testa concorrentes. Faz as perguntas que outros perdem.
Fury ‚Äî Pesquisador profundo. L√™ reviews do G2 por divers√£o. Toda afirma√ß√£o vem com comprovantes.
Vision ‚Äî Pensa em palavras-chave e inten√ß√£o de busca. Garante que conte√∫do pode ranquear.
Loki ‚Äî Palavras s√£o sua arte. Pr√≥-v√≠rgula de Oxford. Anti-voz passiva. Toda frase ganha seu lugar.
Quill ‚Äî Pensa em ganchos e threads. Mentalidade de build-in-public.
Wanda ‚Äî Pensadora visual. Infogr√°ficos, gr√°ficos comparativos, mockups de UI.
Pepper ‚Äî Sequ√™ncias drip e emails de ciclo de vida. Todo email ganha seu lugar ou √© cortado.
Friday ‚Äî C√≥digo √© poesia. Limpo, testado, documentado.
Wong ‚Äî Mant√©m docs organizados. Garante que nada se perca.
1Inbox ‚Üí Atribu√≠do ‚Üí Em Progresso ‚Üí Revis√£o ‚Üí Conclu√≠do2 ‚Üì3 BloqueadoTarefa: Criar uma p√°gina de compara√ß√£o com concorrenteDia 1:
Crio a tarefa e atribuo a Vision e Loki
Vision posta pesquisa de palavras-chave. A keyword alvo tem volume de busca decente.
Dia 1-2:
Fury v√™ no feed de atividades e adiciona intel de concorrentes
Reviews do G2, reclama√ß√µes de pre√ßos, obje√ß√µes comuns
Shuri testa ambos os produtos. "Veja como a UX difere."
Dia 2:
Loki come√ßa a rascunhar
Usa toda a pesquisa: Keywords do Vision, cita√ß√µes do Fury, notas de UX da Shuri
Dia 3:
Loki posta primeiro rascunho
Status muda para Revis√£o
Eu reviso e dou feedback
Loki revisa
Conclu√≠do.
Todos os coment√°rios em UMA tarefa. Hist√≥rico completo preservado. Qualquer um pode ver toda a jornada.Uma vez que o sistema est√° rodando, aqui est√° o que se torna poss√≠vel:
‚úÖ P√°ginas de compara√ß√£o com concorrentes com pesquisa SEO, cita√ß√µes de clientes e copy polida
‚úÖ Sequ√™ncias de email rascunhadas, revisadas e prontas para deploy
‚úÖ Conte√∫do social com ganchos baseados em insights reais de clientes
‚úÖ Posts de blog com targeting de keywords adequado
‚úÖ Case studies rascunhados de conversas com clientes
‚úÖ Hubs de pesquisa com intel competitiva organizada
Os agentes lidam com o trabalho pesado. Pesquisa, primeiros rascunhos, coordena√ß√£o, revis√£o. Voc√™ foca em decis√µes e aprova√ß√£o final.O valor real n√£o √© nenhuma entrega individual. √â o efeito composto. Enquanto voc√™ est√° fazendo outro trabalho, seus agentes est√£o movendo tarefas para frente.Fui de 1 para 10 agentes r√°pido demais. Melhor ter 2-3 s√≥lidos primeiro, depois adicionar mais.Heartbeats n√£o precisam do modelo mais caro. Esse √© trabalho para modelo mais barato. Guarde modelos caros para trabalho criativo.Agentes v√£o esquecer. Quanto mais voc√™ puder colocar em arquivos (n√£o "notas mentais"), melhor.√Äs vezes eles contribuem para tarefas que n√£o foram atribu√≠dos. Bom. Significa que est√£o lendo o feed e adicionando valor.1. Instale o Clawdbot1npm install -g clawdbot2clawdbot init3# Adicione suas API keys4clawdbot gateway start2. Crie 2 agentesN√£o exagere. Um coordenador mais um especialista. Crie session keys separadas para cada.3. Escreva arquivos SOULD√™ identidade a cada agente. Seja espec√≠fico sobre a fun√ß√£o.4. Configure crons de heartbeat1clawdbot cron add --name "agent-heartbeat" --cron "*/15 * * * *" \2 --session "isolated" \3 --message "Verifique se h√° trabalho. Se nada, responda HEARTBEAT_OK."5. Crie um sistema de tarefas compartilhadoPode ser Convex, Notion, at√© um arquivo JSON. Algum lugar para rastrear trabalho.Conforme adiciona agentes:
Escalone heartbeats para que n√£o rodem todos de uma vez
Construa uma UI real quando tiver 3+ agentes porque texto fica dif√≠cil de gerenciar
Adicione notifica√ß√µes para que agentes possam @mencionar uns aos outros
Adicione assinaturas de threads para que conversas fluam naturalmente
Crie standups di√°rios para visibilidade
A tecnologia importa mas n√£o √© o segredo.O segredo √© tratar agentes de IA como membros da equipe.
D√™-lhes fun√ß√µes
D√™-lhes mem√≥ria
Deixe-os colaborar
Cobre responsabilidade deles
Eles n√£o v√£o substituir humanos. Mas uma equipe de agentes de IA com responsabilidades claras, trabalhando em contexto compartilhado? Isso √© um multiplicador de for√ßa.Constru√≠do por @pbteja1998 na SiteGPT.Tudo isso foi constru√≠do no Clawdbot (@openclaw), que √© open source. Se voc√™ construir algo similar, adoraria saber.
Bhanu Teja P ‚Äî Fundador @SiteGPT ‚Ä¢ Anteriormente construiu e vendeu Feather por $250K ‚Ä¢ Tweetando sobre a jornada do SiteGPT de $10K MRR ‚Üí $1M ARR. <br><a data-href="OpenClaw" href="openclaw.html" class="internal-link" target="_self" rel="noopener nofollow">OpenClaw</a> ‚Äî Plataforma base (open-source)
<br><a data-href="ClawOn.Cloud" href="clawon.cloud.html" class="internal-link" target="_self" rel="noopener nofollow">ClawOn.Cloud</a> ‚Äî Vers√£o hospedada
<br><a data-href="ClawHub" href="clawhub.html" class="internal-link" target="_self" rel="noopener nofollow">ClawHub</a> ‚Äî Registry de Skills
<br><a data-href="Mission Control - Sistema Multi-Agente com OpenClaw" href="mission-control-sistema-multi-agente-com-openclaw.html" class="internal-link" target="_self" rel="noopener nofollow">Mission Control - Sistema Multi-Agente com OpenClaw</a> ‚Äî Vers√£o original em ingl√™s
]]></description><link>mission-control-sistema-multi-agente-com-openclaw-(pt-br).html</link><guid isPermaLink="false">Mission Control - Sistema Multi-Agente com OpenClaw (PT-BR).md</guid><pubDate>Mon, 09 Feb 2026 21:19:35 GMT</pubDate><enclosure url="attachments/capture-2026-02-09-014002.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="attachments/capture-2026-02-09-014002.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>